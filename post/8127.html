<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>谈下自动化测试 | 柯捷的记录手册</title><meta name="author" content="柯捷"><meta name="copyright" content="柯捷"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="背景为什么大多数功能测试会觉得测试平台不好用的典型原因 一、接口自动化到底要验证什么-&gt; 做什么事情前，应该想下做的动机和想要达成的目的，这样会减少很多不必要的弯路 1. 自动化的原因 测试界普遍认为应该加自动化用于提高测试效率和保障 测试 kpi 任务 应对需要频繁执行的测试场景 需要增加信心和可靠性   2. 理想中的目的 线上定时巡检，监测系统稳定性，更早地发现问题，减少故障恢复的时间">
<meta property="og:type" content="article">
<meta property="og:title" content="谈下自动化测试">
<meta property="og:url" content="http://example.com/post/8127.html">
<meta property="og:site_name" content="柯捷的记录手册">
<meta property="og:description" content="背景为什么大多数功能测试会觉得测试平台不好用的典型原因 一、接口自动化到底要验证什么-&gt; 做什么事情前，应该想下做的动机和想要达成的目的，这样会减少很多不必要的弯路 1. 自动化的原因 测试界普遍认为应该加自动化用于提高测试效率和保障 测试 kpi 任务 应对需要频繁执行的测试场景 需要增加信心和可靠性   2. 理想中的目的 线上定时巡检，监测系统稳定性，更早地发现问题，减少故障恢复的时间">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/medias/cover7.jpg">
<meta property="article:published_time" content="2024-01-25T12:26:16.000Z">
<meta property="article:modified_time" content="2025-08-26T02:57:32.587Z">
<meta property="article:author" content="柯捷">
<meta property="article:tag" content="自动化测试">
<meta property="article:tag" content="测试理论">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/medias/cover7.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "谈下自动化测试",
  "url": "http://example.com/post/8127.html",
  "image": "http://example.com/medias/cover7.jpg",
  "datePublished": "2024-01-25T12:26:16.000Z",
  "dateModified": "2025-08-26T02:57:32.587Z",
  "author": [
    {
      "@type": "Person",
      "name": "柯捷",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/post/8127.html"><link rel="preconnect"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: '/pluginsSrc/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '谈下自动化测试',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/mycss.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/medias/cover7.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">柯捷的记录手册</span></a><a class="nav-page-title" href="/"><span class="site-name">谈下自动化测试</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">谈下自动化测试</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-25T12:26:16.000Z" title="发表于 2024-01-25 20:26:16">2024-01-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-26T02:57:32.587Z" title="更新于 2025-08-26 10:57:32">2025-08-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/">软件测试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>为什么大多数功能测试会觉得测试平台不好用的典型原因</p>
<h3 id="一、接口自动化到底要验证什么"><a href="#一、接口自动化到底要验证什么" class="headerlink" title="一、接口自动化到底要验证什么"></a>一、接口自动化到底要验证什么</h3><p>-&gt; 做什么事情前，应该想下做的<strong>动机</strong>和想要达成的<strong>目的</strong>，这样会减少很多不必要的弯路</p>
<h5 id="1-自动化的原因"><a href="#1-自动化的原因" class="headerlink" title="1. 自动化的原因"></a>1. 自动化的原因</h5><ul>
<li>测试界普遍认为应该加自动化用于提高测试效率和保障</li>
<li>测试 kpi 任务</li>
<li>应对需要频繁执行的测试场景</li>
<li>需要增加信心和可靠性</li>
</ul>
<hr>
<h5 id="2-理想中的目的"><a href="#2-理想中的目的" class="headerlink" title="2. 理想中的目的"></a>2. 理想中的目的</h5><ul>
<li><p>线上定时巡检，监测系统稳定性，更早地发现问题，减少故障恢复的时间</p>
</li>
<li><p><strong>辅助</strong>提高回归测试质量（就是辅助作用，别想着能靠自动化发现大问题）</p>
</li>
<li><p>记录每次巡检的结果，有助于团队了解系统的历史性能</p>
</li>
</ul>
<hr>
<h5 id="3-接口自动化的设计方向"><a href="#3-接口自动化的设计方向" class="headerlink" title="3. 接口自动化的设计方向"></a>3. 接口自动化的设计方向</h5><p>-&gt; 说到底接口自动化的所有处理就是围绕下面三步去提取测试点和选型工具，并没有什么很高大上的东西，底层还是看写测试点的这个人的<strong>业务水平</strong>，创建出有效的测试点。</p>
<table>
<thead>
<tr>
<th>第一步</th>
<th>第二步</th>
<th>第三步</th>
</tr>
</thead>
<tbody><tr>
<td>发出请求</td>
<td>请求处理</td>
<td>得到回包</td>
</tr>
</tbody></table>
<p>我们基本根据这三步和上面的目的去规划测试点和实现方式<br><img src="/post/8127/1.png"></p>
<ul>
<li>3.1 <strong>工具选择原则</strong>：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">编程语言</th>
<th align="center">测试框架</th>
<th align="left">测试报告</th>
</tr>
</thead>
<tbody><tr>
<td align="center">支持网络编程并有配套的测试框架，学习成本越小越好</td>
<td align="center">稳定&#x2F;易学</td>
<td align="left">直观&#x2F;学习成本低</td>
</tr>
</tbody></table>
<ul>
<li>3.2 <strong>主要测试点提取</strong></li>
</ul>
<p>|    校验项分类    |      校验方式      | 是否起到作用                                         |<br>| :————–: | :—————-: | :————————————————— | — |<br>|                  |                    |                                                      |     |<br>|   <strong>基础检查</strong>   |     状态码检查     | 当前接口是否可用，返回协议状态码是否正确             |<br>|                  |    响应时间检查    | 验证响应时间是否在可接受的范围内                     |<br>|                  |    请求路径检查    | 验证接口路径                                         |<br>|        &gt;         |                    |                                                      |     |<br>|   <strong>数据检查</strong>   |   返回数据一致性   | 验证接口返回是否与预期数据一致，关键参数断言         |<br>|                  |   返回数据的层级   | 验证数据层级变动，防止前端交互裂开                   |<br>|                  |    返回数据格式    | 返回的数据是否符合预期的格式，如 json 或者 xml 等    |<br>|        &gt;         |                    |                                                      |     |<br>| <strong>业务逻辑检查</strong> |    业务规则验证    | 验证接口是否正确地执行了特定的业务规则               |<br>|                  |    返回数据格式    | 返回的数据是否符合预期的格式，如 json 或者 xml 等    |<br>|        &gt;         |                    |                                                      |     |<br>|   <strong>其他用法</strong>   |     吞吐量检查     | 验证接口在一定并发量下的吞吐量是否符合性能要求       |<br>|                  | 响应时间和负载测试 | 在不同的负载下验证接口的响应时间是否在可接受的范围内 |</p>
<ul>
<li>3.3 <strong>测试场景实现难点</strong>（大部分都能借助测试框架解决，解决不了的就用工作流程解决，再解决不了的就不用解决，自动化测试只是<strong>辅助措施</strong>）</li>
</ul>
<p>-&gt; 这里用 pytest 的测试框架来描述解决方法，不同的测试框架自己找对应的方法</p>
<table>
<thead>
<tr>
<th align="center">场景</th>
<th align="center">描述</th>
<th align="left">pytest 解决方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">接口依赖</td>
<td align="center">多个接口之间存在依赖关系，如：接口 A 输出可能是接口 B 的输入</td>
<td align="left">@pytest.fixture 允许你定义和共享测试用例之间的资源和设置</td>
</tr>
<tr>
<td align="center">动态数据和状态管理</td>
<td align="center">动态数据如：时间戳等，状态管理如：登录状态、用户权限状态、资源分配状态等</td>
<td align="left">@pytest.fixture 前后置允许你动态生成或设置数据，以适应接口返回的动态变化</td>
</tr>
<tr>
<td align="center">错误重试</td>
<td align="center">有时候环境问题导致执行失败，需要进行重试</td>
<td align="left">使用 pytest-rerunfailures 插件，通过 –reruns 和 –reruns-delay 选项指定重试的次数和延迟时间</td>
</tr>
<tr>
<td align="center">数据驱动测试</td>
<td align="center">在相同测试用例上使用不同的输入数据，以增加测试覆盖率</td>
<td align="left">@pytest.mark.parametrize，实现数据驱动测试</td>
</tr>
<tr>
<td align="center">并行执行</td>
<td align="center">需要提高用例执行速度</td>
<td align="left">使用插件 pytest-xdist 来实现并行执行测试用例</td>
</tr>
</tbody></table>
<hr>
<h5 id="4-自动化实现中的实际痛点"><a href="#4-自动化实现中的实际痛点" class="headerlink" title="4. 自动化实现中的实际痛点"></a>4. 自动化实现中的实际痛点</h5><p>-&gt; 现在的普遍论调应该基本都是在技术优化上，但是实际上自动化测试的实际痛点的本质上因为人的痛点：</p>
<ul>
<li><p>1.日益增长的工作内容同有限人力之间的矛盾</p>
<ul>
<li>有限的测试人力无法满足日益增加的测试需求&#x2F;要求</li>
<li>引入自动化测试无法减少工作量的增加，却要挤出时间和资源去实施和维护一个<em>辅助</em>性质的自动化</li>
</ul>
</li>
<li><p>2.理想化愿景与实际可行性之间的矛盾</p>
<ul>
<li>平台化设计过度复杂，想要覆盖各种测试需求，导致用例创建繁琐、学习曲线陡峭</li>
<li>妄想匹配所有项目需求，不断细化和组件化等，导致失去灵活性、增加维护成本</li>
</ul>
</li>
<li><p>3.技术追求与实际需求之间不平衡的矛盾</p>
<ul>
<li>倾向于追求更高级、复杂的技术，以展示其专业技能，导致出现用很复杂的流程和实现方式去验证一件反而简单的事</li>
<li>封装过度，导致代码难以理解和维护（我们不是开发，没必要防御性编程）</li>
</ul>
</li>
<li><p>解决思路：</p>
<ul>
<li>1&gt;自动化设计就要立足于实际的项目需要，只关注当前项目的核心功能和业务流程，不盲目追求覆盖率，只对关键路径、核心功能和高风险场景进行自动化，不一定动辄就是测试平台</li>
<li>2&gt; 接口自动化性价比最高的就是脚本化（复制粘贴是真的方便）搭配一个成熟的测试框架，不搞花里胡哨的封装和平台化，力求易读、易维护的自动化测试脚本</li>
<li>3&gt; 不追求更高级的技术，注重实用性&#x2F;快捷性，自动化的关键点不是你用了什么技术去做请求断言返回，而是你的这个用例关注的方向对没。（你用 Java 搞了个平台创建断言了接口返回 和 我用 postman 写了个脚本断言返回，测试结果效果上有什么质的区别吗？）</li>
</ul>
</li>
</ul>
<h3 id><a href="#" class="headerlink" title="-"></a>-</h3><hr>
<h5 id="5-自动化搭建大致过程"><a href="#5-自动化搭建大致过程" class="headerlink" title="5. 自动化搭建大致过程"></a>5. 自动化搭建大致过程</h5><ul>
<li><ol>
<li>选择一个合适的工具</li>
</ol>
</li>
<li><ol start="2">
<li>根据我上面<strong>主要测试点提取</strong>的表，选择需要验证的内容进行断言</li>
</ol>
</li>
<li><ol start="3">
<li>利用 codeGeex&#x2F;gpt 的辅助，一步步把需要完成的自动化搭起来</li>
</ol>
</li>
<li><ol start="4">
<li>后续随着用例数和场景复杂了，遇到什么问题就有什么解决什么，你不可能一开始就能想到全部的问题</li>
</ol>
</li>
</ul>
<p>如果你是用 python，大致用到的就是这些，除了通用的 http 请求，如果有其他协议，就找对应协议的库</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">测试框架：</span><br><span class="line">pytest： 用于编写和执行测试用例，支持参数化测试、夹具等功能。</span><br><span class="line">HTTP请求库：requests： 用于发送HTTP请求，方便处理接口的GET、POST等操作</span><br><span class="line">数据驱动：yaml： 用于存储测试数据，例如接口请求参数、期望响应等。可以使用PyYAML库解析YAML格式的数据文件。</span><br><span class="line">数据库连接：mysql-connector-python，用于与MySQL数据库建立连接，执行数据库操作，例如验证接口返回的数据与数据库中的数据是否一致。</span><br><span class="line">日志记录：logbook，用于记录测试过程中的日志信息，有助于排查问题和进行调试。</span><br><span class="line">报告生成：allure-pytest，结合pytest和Allure生成详细的测试报告，提供可视化的测试结果和执行历史。</span><br></pre></td></tr></table></figure>

<h3 id="二、目前测试平台有什么奇怪点"><a href="#二、目前测试平台有什么奇怪点" class="headerlink" title="二、目前测试平台有什么奇怪点"></a>二、目前测试平台有什么奇怪点</h3><p>了解问题的核心关键在于“从群众中来,到群众中去”，这句话同样适用于测试岗，很多平台都会标注 【<em>独特的用例编写方式</em>】、【<em>低门槛，易使用</em>】的特性，但是实际上都是粗制 web 化的 jmeter 或者粗制 web 化的 postman 又或者是奇葩的低代码拖拽，不仅创建用例麻烦不灵活 且 调试接口费时间，功能细化和封装过度也导致了不小的学习使用成本，且该学习成本不像 jmeter 这种工具的使用经验那样可复用。这些既不能提高效率又不能用来提高测试水平的做法用一句话来形容的话就是：“离群众太远了”。</p>
<h5 id="1-测试平台使用槽点"><a href="#1-测试平台使用槽点" class="headerlink" title="1. 测试平台使用槽点"></a>1. 测试平台使用槽点</h5><p>测试平台交互模式： - 1. 创建项目 -&gt;创建模块-&gt;创建 case-&gt;关联项目-&gt;关联模块 - 2. 编写 case：请求参数、前后置、预期值等多个输入框，需要逐个点击填写信息(和 jmeter 创建用例的方式有什么区别？),当接口发生变更时，也是需要逐个用例手动修改信息，维护成本高,用例的可读性也差 - 3.调试 case: 调试信息不够清晰且慢，调试出问题时也无法马上明确是平台问题还是接口本身问题</p>
<h5 id="2-测试平台的设计通病"><a href="#2-测试平台的设计通病" class="headerlink" title="2. 测试平台的设计通病"></a>2. 测试平台的设计通病</h5><pre><code>  - 把【低门槛，易使用】理解为：不用写代码就是容易用，抛开实际意义上的实用。
  - 太想通用：平台的灵活性本身比较差，为了增加灵活性又为了考虑功能测试不懂代码，通常都会将多种操作流程组件化，增加很多配置项。但是一件产品如果是一端的产出，没有对应的产品、测试和持续的用户反馈，必定会有设计不当或者过度组件化，导致测试用例的抽象层次变得复杂、上手难度增加、执行有性能问题等
  - 鸡肋：为体现自身技术，选型难度较大的前后端技术栈，过度追求技术炫耀让平台更难理解和使用，底层逻辑还是走的对返回包的断言，导致难以让人信服。就像赛博丁真绕了个大圈关灯一样
</code></pre>
<h5 id="3-意识形态差异："><a href="#3-意识形态差异：" class="headerlink" title="3. 意识形态差异："></a>3. 意识形态差异：</h5><pre><code>- 都什么年代了，现在面试功能测试哪个不要求基本的代码脚本能力？，更别说现在都有gpt加持，真的不用特别考虑测试无代码能力的场景
- 都是测试，肯定是希望通过写脚本去巩固自己熟悉的开发语言，即使繁琐，也有学习成长的快感
</code></pre>
<hr>
<h3 id="三、写自动化的心理误区"><a href="#三、写自动化的心理误区" class="headerlink" title="三、写自动化的心理误区"></a>三、写自动化的心理误区</h3><h5 id="1-没使用设计模式，很心虚"><a href="#1-没使用设计模式，很心虚" class="headerlink" title="1. 没使用设计模式，很心虚"></a>1. 没使用设计模式，很心虚</h5><ul>
<li>特别是新手，认为如果没有使用设计模式来编写自动化测试代码，就会感到不够专业或不足够好。</li>
<li>设计模式的确在自动化测试中可以提高代码的可维护性和可扩展性，但并非所有项目都需要复杂的设计模式。如果你只是为了实现简单的接口测试，引入设计模式只会导致代码过于复杂，增加了维护成本。</li>
<li>设计模式是一个不断演进的过程，可以在需要的时候逐步引入，而不必为了设计模式而设计模式。始终专注于编写简单、可读、可维护的脚本。</li>
</ul>
<p>哪怕你用下面最简单明了的模式，哪又怎样？ 能达到自动化的目的即可，干嘛要折磨自己（个人见解，大佬忽略）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">project_root/</span><br><span class="line">|-- api_tests/     存放 API 测试用例的目录</span><br><span class="line">|   |-- project1/      项目1</span><br><span class="line">|   |   |-- __init__.py</span><br><span class="line">|   |   |-- test_api_project1.py</span><br><span class="line">|   |   |-- utils/</span><br><span class="line">|   |       |-- __init__.py</span><br><span class="line">|   |       |-- api_client_project1.py   封装 API 请求的客户端工具</span><br><span class="line">|   |-- project2/          项目2</span><br><span class="line">|       |-- __init__.py</span><br><span class="line">|       |-- test_api_project2.py</span><br><span class="line">|       |-- utils/</span><br><span class="line">|           |-- __init__.py</span><br><span class="line">|           |-- api_client_project2.py   封装 API 请求的客户端工具</span><br><span class="line">|-- conftest.py      共享的 fixture 和配置信息</span><br><span class="line">|-- pytest.ini          Pytest 的配置文件</span><br><span class="line">|-- requirements.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-过度关注工具而非测试目标"><a href="#2-过度关注工具而非测试目标" class="headerlink" title="2. 过度关注工具而非测试目标"></a>2. 过度关注工具而非测试目标</h5><ul>
<li>Java 的 TestNG、python 的 pytest、jmeter、postman 还是在前面工具基础上封装平台，本质上都是向目标接口发出请求再进行断言，不管技术实现上有多难，最后实现的测试目标都是一样的。</li>
<li>自动化最终难题都在<em>用例维护</em>和管理上，即使平台化也是如此。</li>
<li>测试用例的设计和执行质量直接影响测试的有效性，良好设计的测试用例可以更好地捕捉潜在的问题，而低质量的测试用例可能导致遗漏重要的测试点</li>
</ul>
<h5 id="3-一切都可以自动化"><a href="#3-一切都可以自动化" class="headerlink" title="3. 一切都可以自动化"></a>3. 一切都可以自动化</h5><ul>
<li>自动化是业务逻辑抽象的结果，只是业务逻辑测试的一种方式，相比手工的确是效率更高些，但是需要一个基础条件：稳定的项目</li>
</ul>
<h5 id="4-试图一步到位"><a href="#4-试图一步到位" class="headerlink" title="4. 试图一步到位"></a>4. 试图一步到位</h5><ul>
<li>一开始就想覆盖所有的接口和测试场景，徒增压力和维护成本</li>
<li>要逐步增量的方法，从一些核心的接口和关键的测试场景开始，逐步扩展测试范围。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">柯捷</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/post/8127.html">http://example.com/post/8127.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">柯捷的记录手册</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/">自动化测试</a><a class="post-meta__tags" href="/tags/%E6%B5%8B%E8%AF%95%E7%90%86%E8%AE%BA/">测试理论</a></div><div class="post-share"><div class="social-share" data-image="/medias/cover7.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/post/14582.html" title="牛奶打奶泡原理"><img class="cover" src="/medias/cover18.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">牛奶打奶泡原理</div></div><div class="info-2"><div class="info-item-1">牛奶打发 牛奶主要组成[ 乳糖 ​ ​]乳糖在牛奶温度在 53-57 度时甜味感最强,因此,温牛奶比冰牛奶更容易让人感到甜美可口 [ 蛋白质 ​]在冷牛奶中蛋白质是折叠的状态，通过加热引起蛋白质变性和重排，露出亲水端和疏水端使用蒸汽棒往牛奶里注入空气时，蛋白质的疏水端为了避开牛奶中的水埋入气泡中就，使得亲水端在气泡外形成一层屏障 并保持气泡的形状, 奶泡就是这样借住蛋白的表面活性作用形成。直到 70 摄氏度时，蛋白质散开或者变性，让蛋白质包裹的气泡破裂，使奶泡劣化，因此奶泡的加热温度不能过高  在图中，蛋白质的疏水端（红色）指向气泡内部，避开水分子，而亲水端（绿色）指向外部，与水分子接触。这个结构使气泡稳定，形成了一层保护气泡的屏障，从而保持气泡的形状。：    气泡（淡蓝色圆形）：表示牛奶中的空气气泡。 水分子（蓝色小圆点）：围绕在气泡周围。 蛋白质分子（红色和绿色圆点，连线表示分子结构）：红色圆点表示蛋白质的疏水端，绿色圆点表示蛋白质的亲水端。  [ 脂肪 ​ ​]脂肪影响奶泡的厚度、质量和持续的时间，脂肪含量越多，奶泡越浓厚且奶泡持续的时间也越长打奶泡时气泡彼此相互接触和堆...</div></div></div></a><a class="pagination-related" href="/post/48358.html" title="功能测试工作常见9大问题及应对策略"><img class="cover" src="/medias/cover1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">功能测试工作常见9大问题及应对策略</div></div><div class="info-2"><div class="info-item-1">在功能测试的日常工作中，需求评估、任务冲突、线上故障等问题频发，直接影响测试效率与项目质量。本文梳理了测试人员高频遇到的 9 类核心问题，并结合实战经验提供可落地的应对方案，帮助测试从业者更从容地处理工作挑战。 问题一：测试时间评估测试时间的科学评估需要综合多维度不确定因素，但实际工作中常因信息滞后、任务并行导致评估被动。 理论上，需纳入以下因素综合判断，再通过多方沟通确认合理时间：  需求变更频率与范围 开发进度是否存在延误风险 Bug 修复的稳定性（是否反复出现） 业务流程的复杂程度 测试环境的稳定性（是否频繁断连） 上下游服务的依赖关系（如接口依赖、数据依赖） 测试人员资源分配（是否有专人对接） 是否引入新技术（需额外学习成本） 回归测试的覆盖范围  但现实场景往往是：一个功能测试需同时跟进多个项目，且通常是最晚知晓新需求的人——常被“冷不丁”拉入需求评审会，产品快速讲完需求后，就要求立即给出测试时间，以便其推进后续工作。 针对不同场景，可参考以下应对方法：  临时被拉进会议，需立即预估时间先询问开发的预估开发时长，再根据现场沟通氛围，将测试时间设定为开发时间的 50%-8...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">柯捷</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn"><i class="iconfont icon-youxishoubing"></i><span>小程序</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><p>欢迎来到我的博客！</p><div class='xpand' style='height:200px;'><canvas class='illo' width='800' height='800' style='max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;'></canvas></div><script src='https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople1.js'></script><script src='https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/zdog.dist.js'></script><script src='https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople.js'></script><style>.card-widget.card-announcement {margin: 0;align-items: center;justify-content: center;text-align: center;}canvas {display: block;margin: 0 auto;cursor: move;}</style></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%B0%E5%BA%95%E8%A6%81%E9%AA%8C%E8%AF%81%E4%BB%80%E4%B9%88"><span class="toc-number">2.</span> <span class="toc-text">一、接口自动化到底要验证什么</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.0.1.</span> <span class="toc-text">1. 自动化的原因</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%90%86%E6%83%B3%E4%B8%AD%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-number">2.0.2.</span> <span class="toc-text">2. 理想中的目的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E5%90%91"><span class="toc-number">2.0.3.</span> <span class="toc-text">3. 接口自动化的设计方向</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%9A%84%E5%AE%9E%E9%99%85%E7%97%9B%E7%82%B9"><span class="toc-number">2.0.4.</span> <span class="toc-text">4. 自动化实现中的实际痛点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">-</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%90%AD%E5%BB%BA%E5%A4%A7%E8%87%B4%E8%BF%87%E7%A8%8B"><span class="toc-number">3.0.1.</span> <span class="toc-text">5. 自动化搭建大致过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%9B%AE%E5%89%8D%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%87%E6%80%AA%E7%82%B9"><span class="toc-number">4.</span> <span class="toc-text">二、目前测试平台有什么奇怪点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E4%BD%BF%E7%94%A8%E6%A7%BD%E7%82%B9"><span class="toc-number">4.0.1.</span> <span class="toc-text">1. 测试平台使用槽点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E9%80%9A%E7%97%85"><span class="toc-number">4.0.2.</span> <span class="toc-text">2. 测试平台的设计通病</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%84%8F%E8%AF%86%E5%BD%A2%E6%80%81%E5%B7%AE%E5%BC%82%EF%BC%9A"><span class="toc-number">4.0.3.</span> <span class="toc-text">3. 意识形态差异：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%86%99%E8%87%AA%E5%8A%A8%E5%8C%96%E7%9A%84%E5%BF%83%E7%90%86%E8%AF%AF%E5%8C%BA"><span class="toc-number">5.</span> <span class="toc-text">三、写自动化的心理误区</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%B2%A1%E4%BD%BF%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%BE%88%E5%BF%83%E8%99%9A"><span class="toc-number">5.0.1.</span> <span class="toc-text">1. 没使用设计模式，很心虚</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%BF%87%E5%BA%A6%E5%85%B3%E6%B3%A8%E5%B7%A5%E5%85%B7%E8%80%8C%E9%9D%9E%E6%B5%8B%E8%AF%95%E7%9B%AE%E6%A0%87"><span class="toc-number">5.0.2.</span> <span class="toc-text">2. 过度关注工具而非测试目标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%B8%80%E5%88%87%E9%83%BD%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%8A%A8%E5%8C%96"><span class="toc-number">5.0.3.</span> <span class="toc-text">3. 一切都可以自动化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E8%AF%95%E5%9B%BE%E4%B8%80%E6%AD%A5%E5%88%B0%E4%BD%8D"><span class="toc-number">5.0.4.</span> <span class="toc-text">4. 试图一步到位</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/34420.html" title="从零到一：我用Cursor搓出的摸鱼小程序"><img src="/medias/cover20.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="从零到一：我用Cursor搓出的摸鱼小程序"/></a><div class="content"><a class="title" href="/post/34420.html" title="从零到一：我用Cursor搓出的摸鱼小程序">从零到一：我用Cursor搓出的摸鱼小程序</a><time datetime="2025-08-26T04:42:52.000Z" title="发表于 2025-08-26 12:42:52">2025-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/60841.html" title="论路由器与 Robot Framework 是否强关联？"><img src="/medias/cover11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论路由器与 Robot Framework 是否强关联？"/></a><div class="content"><a class="title" href="/post/60841.html" title="论路由器与 Robot Framework 是否强关联？">论路由器与 Robot Framework 是否强关联？</a><time datetime="2025-08-25T08:35:29.000Z" title="发表于 2025-08-25 16:35:29">2025-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/17770.html" title="关于招聘时的一点人性复杂"><img src="/medias/cover5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于招聘时的一点人性复杂"/></a><div class="content"><a class="title" href="/post/17770.html" title="关于招聘时的一点人性复杂">关于招聘时的一点人性复杂</a><time datetime="2025-08-25T08:16:19.858Z" title="发表于 2025-08-25 16:16:19">2025-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/12278.html" title="从水帖数认识机器学习"><img src="/medias/cover12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="从水帖数认识机器学习"/></a><div class="content"><a class="title" href="/post/12278.html" title="从水帖数认识机器学习">从水帖数认识机器学习</a><time datetime="2025-08-25T07:21:01.117Z" title="发表于 2025-08-25 15:21:01">2025-08-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/25326.html" title="讽刺情景剧：如果真为学习，少加点技术群"><img src="/medias/cover3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="讽刺情景剧：如果真为学习，少加点技术群"/></a><div class="content"><a class="title" href="/post/25326.html" title="讽刺情景剧：如果真为学习，少加点技术群">讽刺情景剧：如果真为学习，少加点技术群</a><time datetime="2025-08-20T09:03:36.000Z" title="发表于 2025-08-20 17:03:36">2025-08-20</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By 柯捷</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="/pluginsSrc/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>